# 电赛101 入门版

*本文作者水平有限，社畜加班大脑退化，可能出现笔误或事实错误，请读者谅解*

*本文采用 [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/legalcode.txt)协议*

*创建时间：2024/10/01 🎂*


*作者： nmpassthf nmpassthf@gmail.com*

在电赛中，同学们需要编写的软件大部分是面向**低功耗Arm**芯片的，所以本教程将以 **STM32F429** 这款芯片为样例，向同学们简单介绍一下如何安装所需的开源工具并自己动手编写一个嵌入式程序。

------

[TOC]

------

## Chap 0 什么是嵌入式程序？

众所周知，以**C语言**为例，构建一个可以在桌面环境中可以运行的程序的基本步骤为：**编写Source-编译-链接-运行-(调试)** 

在嵌入式环境中，流程也是一致的，只不过和我们之前所学到的程序有些许异同：

1、运行环境: **嵌入式程序通常是一个裸机程序，或运行在实时操作系统中**

因此，通常**不推荐**一个嵌入式程序使用堆内存。这是由于：

- 通常情况下嵌入式环境中的认为划分给堆的内存比较少。
- 一旦出现内存泄漏几乎没有操作系统兜底。
- 引入堆内存会极大地降低程序的鲁棒性，并提高软件部分的复杂度。

2、硬件环境：**嵌入式程序通常运行在MCU中，通过GPIO、ADC、DAC等物理外设实现各类功能**

因此，一个嵌入式程序的程序本身的大小和运行时大小将受限于MCU内置的flash大小和扩展的flash、sdram存储容量。在分配栈变量和全局变量的时候需要特别注意内存的占用问题。

同时，近乎所有外设都需要程序员通过写寄存器等方式**自行初始化**。

初始化外设，并为各种外设编写程序就是嵌入式程序主要的内容。

3、编译环境：嵌入式程序的**底层CPU架构**（ARM Cortex-M之类的）通常与你编写程序的环境（x86_64、AArch64）**不一致**

因此，为了编译并调试异构程序，我们才需要使用特殊的工具链**交叉编译**：在本机的架构中编写、编译、链接其他架构的程序。

4、烧录和调试：

由于嵌入式MCU通常使用内置的SRAM、flash作为存储单元，因此编译好的程序也需要使用对应的硬件烧录器将程序写入到芯片内部中。

常见的调试器同时也具备烧录的功能（例如ST的ST-LINK/V2），因此我们可以通过硬件调试器来烧录程序或者让GDB detach到嵌入式的程序中打断点调试。

## Chap 1 编写-编译-烧录-调试 所需的工具

### Chap 1.1 工具链简介

在此文中，我将介绍使用**VSCode + CubeMX + XMake (GNU make)+ Arm-none-eabi-GCC + OpenOCD**工具来构建一个嵌入式工程。

在此，不对这些开源工具做过多教程，这些工具的官网都有很详细的文档，大家可以先按照我的配置过程稍加改动，适应自己的开发板即可。

在这串工具中，我们使用：

**VSCode**编辑、浏览、调试代码。

**CubeMX**创建工程并复制所需的HAL（或者LL）库到我们的工程路径，并生成我们所需的链接脚本和启动汇编。

**交叉编译器**:ARM发行的**arm-none-eabi-gcc**。

**OpenOCD**将生成的hex文件烧录到目标单片机。

**OpenOCD+GDB**远程调试嵌入式程序。

可选项：

**Git**版本控制软件，方便管理源码的版本。

### Chap 1.2 自动化构建软件

对于一个源文件众多的大型应用来说，使用这类自动化构建软件可以极大地减少编译时的工作量，并加快编译速度。对于C/C++语言构建的项目来说，XMake、CMake和GNU make等一众软件都可以实现此功能。

因为选择不同的自动化构建软件会**影响到接下来配置VSCode编辑器的插件**，因此本文列出了两类区别较大的自动化构建软件。

**可以根据自身喜好选择其一使用**

[Chap3](#Chap3使用XMake+clangdIntelliSense) 中将详细介绍基于XMake工具的配置方法。

[Chap4](#chap-4-使用GNU-make--microsoft-cc-intellisense) 中将详细介绍基于GNU make工具的配置方法。

### Chap 1.3 安装前知识点

#### Chap 1.3.1 环境变量

指的是将某一个可以运行的可执行程序的**目录**添加进操作系统的Path搜索目录中。

（e.g. 将位于`C:\ENV\openocd\bin\openocd.exe` 的**openocd可执行程序**加入path，请将`C:\ENV\openocd\bin`追加写入**Path**中）

在Windows 11的操作流程为：

![1.3.1.1](./Assets/Sc/1.3.1.1.png)

![1.3.1.2](./Assets/Sc/1.3.1.2.png)

Linux 下可以通过向 `/etc/profile.d/`下新增profile文件，并使用如下命令添加环境变量。

```sh
export PATH='$PATH:/usr/local/openocd/bin'
```

#### Chap 1.3.2 善用互联网

很多问题都可以在网上获取到答案。

编程类问题：推荐使用英文在Google等搜索引擎中检索，这比留言提问高效的多 。

编译参数/软件选项/使用文档：推荐查询对应软件的官网，都会整理出Document或Manual（注意版本号）。

e.g. [GNU Make Manual](https://www.gnu.org/software/make/manual/make.html)

## Chap 2 基础组件安装

本文中，默认读者使用最新的 x86_64架构的 Windows 10/11 64bit 操作系统。

*对于使用Ubuntu或Fedora等Linux系统的读者，可以通过包管理器简化安装的步骤；部分配置项和路径可能与文中所列不同。*

***文中大部分工具使用默认安装路径，请注意核对你自己文件路径***

### Chap 2.1 STM32CubeMX

STM32CubeMX是ST公司推出的一个自动化代码生成器，我们可以通过此工具便利的下载到ST的MCU的相关开发SDK、配置MCU相关参数并自动生成工程。

我们可以从ST的官网获取此软件：[STM32CubeMX](https://www.st.com/en/development-tools/stm32cubemx.html)

### Chap 2.2 MSYS2

> 本章节参考了[MSYS2 Installer](https://www.msys2.org/docs/installer/)

考虑到我们可能使用GNU工具链(GNU Make/GCC等工具)，获取其最便利的方式是通过MSYS2的pacman包管理器安装这些工具。

MSYS2是一个工具和库的集合，它提供了一个基于开源软件的本地构建环境，用于构建、安装和运行本地 Windows 软件。

MSYS2 Installer可以从[MSYS2 Installer distrib](https://repo.msys2.org/distrib/) 或其 Github仓库获取

下载其中的 `msys2-x86_64-latest.exe`然后使用 

```cmd
.\msys2-x86_64-latest.exe in --confirm-command --accept-messages --root C:/msys64
```

安装MSYS2到默认路径：`C:/msys64`中。

### Chap 2.3 GCC

如前几节所述，由于我们需要使用交叉编译器，因此需要获取arm-none-eabi-gcc编译器。

arm-none-eabi-gcc的名字代表：

- arm: 它编译的target是arm架构的
- none: 没有目标操作系统
- eabi: 嵌入式ABI
- gcc: GCC

### Chap 2.4 OpenOCD

### Chap 2.5 Git

> 本章节参考了 [Install inside MSYS2 proper](https://github.com/git-for-windows/git/wiki/Install-inside-MSYS2-proper)



## Chap 3 使用XMake + clangd IntelliSense

*章节提示：Chap 3 和 Chap 4选择其一即可*

### Chap 3.1 XMake安装

### Chap 3.2 VSCode(clangd)安装

## Chap 4 使用GNU make + Microsoft C/C++ IntelliSense

*章节提示：Chap 3 和 Chap 4选择其一即可*

### Chap 4.1 GNU make安装

### Chap 4.2 VSCode(ms IntelliSense)安装